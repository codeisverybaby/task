// use tokio::net::UdpSocket;
// use std::sync::Arc;
// use std::time::Duration;

// #[tokio::main]
// async fn main() -> std::io::Result<()> {
//     let socket = Arc::new(UdpSocket::bind("0.0.0.0:8080").await?);
//     let target = "127.0.0.1:1337";

//     println!("Server started, sending 'Hello' to {}", target);

//     // üÜï Task g·ª≠i "Hello" m·ªói 2 gi√¢y
//     let socket_send = Arc::clone(&socket);
//     tokio::spawn(async move {
//         loop {
//             match socket_send.send_to(b"Hello", target).await {
//                 Ok(_) => println!("Sent 'Hello' to {}", target),
//                 Err(e) => eprintln!("Send error: {}", e),
//             }
//             tokio::time::sleep(Duration::from_secs(2)).await;
//         }
//     });

//     // Task nh·∫≠n d·ªØ li·ªáu t·ª´ client
//     let socket_recv = Arc::clone(&socket);
//     tokio::spawn(async move {
//         let mut buf = vec![0; 1024];
//         loop {
//             match socket_recv.recv_from(&mut buf).await {
//                 Ok((size, addr)) => {
//                     println!("Received from {}: {}", addr, String::from_utf8_lossy(&buf[..size]));
//                 }
//                 Err(e) => {
//                     eprintln!("Receive error: {}", e);
//                 }
//             }
//         }
//     });

//     // Gi·ªØ ch∆∞∆°ng tr√¨nh ch·∫°y v√¥ h·∫°n
//     loop {
//         tokio::time::sleep(Duration::from_secs(60)).await;
//     }
// }


use std::net::UdpSocket;
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;

fn main() {
    // 1Ô∏è‚É£ T·∫°o socket v√† bind v√†o ƒë·ªãa ch·ªâ
    let socket = UdpSocket::bind("0.0.0.0:8080").expect("Could not bind socket");
    socket.set_nonblocking(true).expect("Failed to set non-blocking");

    // D√πng Arc<Mutex<UdpSocket>> ƒë·ªÉ chia s·∫ª socket gi·ªØa c√°c thread
    let socket = Arc::new(Mutex::new(socket));

    // 2Ô∏è‚É£ T·∫°o thread nh·∫≠n d·ªØ li·ªáu t·ª´ client
    let socket_recv = Arc::clone(&socket);
    thread::spawn(move || {
        let mut buf = [0; 1024];
        loop {
            let socket = socket_recv.lock().unwrap();
            match socket.recv_from(&mut buf) {
                Ok((size, addr)) => {
                    println!("Received from {}: {}", addr, String::from_utf8_lossy(&buf[..size]));
                }
                Err(_) => {} // Kh√¥ng nh·∫≠n ƒë∆∞·ª£c th√¨ b·ªè qua
            }
            drop(socket); // Gi·∫£i ph√≥ng Mutex tr∆∞·ªõc khi loop ti·∫øp t·ª•c
            thread::sleep(Duration::from_millis(100)); // Tr√°nh CPU ch·∫°y 100%
        }
    });

    // 3Ô∏è‚É£ T·∫°o thread g·ª≠i d·ªØ li·ªáu "Hello" m·ªói 2 gi√¢y
    let socket_send = Arc::clone(&socket);
    thread::spawn(move || {
        let target = "127.0.0.1:1337";
        loop {
            {
                let socket = socket_send.lock().unwrap();
                match socket.send_to(b"Hello", target) {
                    Ok(_) => println!("Sent 'Hello' to {}", target),
                    Err(e) => eprintln!("Send error: {}", e),
                }
            }
            thread::sleep(Duration::from_secs(2)); // Ch·ªù 2 gi√¢y r·ªìi g·ª≠i ti·∫øp
        }
    });

    // Gi·ªØ ch∆∞∆°ng tr√¨nh ch·∫°y m√£i m√£i
    loop {
        thread::sleep(Duration::from_secs(60));
    }
}
