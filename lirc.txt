#include <alsa/asoundlib.h>
#include <iostream>
#include <fstream>
#include <vector>

// Ghi header WAV PCM
void WriteWavHeader(std::ofstream &file, int sampleRate, int channels, int bitsPerSample, int dataSize) {
    int byteRate = sampleRate * channels * bitsPerSample / 8;
    int blockAlign = channels * bitsPerSample / 8;
    int chunkSize = 36 + dataSize;

    file.write("RIFF", 4);
    file.write((char *)&chunkSize, 4);
    file.write("WAVE", 4);
    file.write("fmt ", 4);

    int subChunk1Size = 16;
    short audioFormat = 1; // PCM
    file.write((char *)&subChunk1Size, 4);
    file.write((char *)&audioFormat, 2);
    file.write((char *)&channels, 2);
    file.write((char *)&sampleRate, 4);
    file.write((char *)&byteRate, 4);
    file.write((char *)&blockAlign, 2);
    file.write((char *)&bitsPerSample, 2);

    file.write("data", 4);
    file.write((char *)&dataSize, 4);
}

// Record từ 1 thiết bị ALSA
std::vector<char> RecordALSA(const char *device, int seconds, int sampleRate = 44100, int channels = 2, int bitsPerSample = 16) {
    snd_pcm_t *pcmHandle;
    snd_pcm_hw_params_t *params;

    int dir;
    snd_pcm_open(&pcmHandle, device, SND_PCM_STREAM_CAPTURE, 0);
    snd_pcm_hw_params_malloc(&params);
    snd_pcm_hw_params_any(pcmHandle, params);

    snd_pcm_hw_params_set_access(pcmHandle, params, SND_PCM_ACCESS_RW_INTERLEAVED);
    snd_pcm_hw_params_set_format(pcmHandle, params, SND_PCM_FORMAT_S16_LE);
    snd_pcm_hw_params_set_channels(pcmHandle, params, channels);
    snd_pcm_hw_params_set_rate_near(pcmHandle, params, (unsigned int *)&sampleRate, &dir);

    snd_pcm_hw_params(pcmHandle, params);
    snd_pcm_hw_params_free(params);
    snd_pcm_prepare(pcmHandle);

    int frameSize = channels * (bitsPerSample / 8);
    int bufferFrames = 1024;
    std::vector<char> buffer(bufferFrames * frameSize);
    std::vector<char> audioData;

    int loops = (seconds * sampleRate) / bufferFrames;
    for (int i = 0; i < loops; i++) {
        int rc = snd_pcm_readi(pcmHandle, buffer.data(), bufferFrames);
        if (rc == -EPIPE) {
            std::cerr << "Overrun occurred\n";
            snd_pcm_prepare(pcmHandle);
        } else if (rc < 0) {
            std::cerr << "Error reading: " << snd_strerror(rc) << "\n";
        } else {
            audioData.insert(audioData.end(), buffer.begin(), buffer.begin() + rc * frameSize);
        }
    }

    snd_pcm_drain(pcmHandle);
    snd_pcm_close(pcmHandle);

    return audioData;
}

void SaveToWav(const std::string &filename, const std::vector<char> &data, int sampleRate, int channels, int bitsPerSample) {
    std::ofstream out(filename, std::ios::binary);
    WriteWavHeader(out, sampleRate, channels, bitsPerSample, (int)data.size());
    out.write(data.data(), data.size());
    out.close();
}

int main() {
    // Record microphone (default device)
    auto micData = RecordALSA("default", 5);
    SaveToWav("mic_record.wav", micData, 44100, 2, 16);
    std::cout << "Saved mic_record.wav\n";

    // Record loopback (cần enable module snd-aloop trước)
    // sudo modprobe snd-aloop
    // device có thể là: "hw:Loopback,1,0"
    auto loopData = RecordALSA("hw:Loopback,1,0", 5);
    SaveToWav("loopback_record.wav", loopData, 44100, 2, 16);
    std::cout << "Saved loopback_record.wav\n";

    return 0;
}


#include <pulse/simple.h>
#include <pulse/error.h>
#include <iostream>
#include <fstream>
#include <vector>

// Ghi header WAV PCM
void WriteWavHeader(std::ofstream &file, int sampleRate, int channels, int bitsPerSample, int dataSize) {
    int byteRate = sampleRate * channels * bitsPerSample / 8;
    int blockAlign = channels * bitsPerSample / 8;
    int chunkSize = 36 + dataSize;

    file.write("RIFF", 4);
    file.write((char *)&chunkSize, 4);
    file.write("WAVE", 4);
    file.write("fmt ", 4);

    int subChunk1Size = 16;
    short audioFormat = 1; // PCM
    file.write((char *)&subChunk1Size, 4);
    file.write((char *)&audioFormat, 2);
    file.write((char *)&channels, 2);
    file.write((char *)&sampleRate, 4);
    file.write((char *)&byteRate, 4);
    file.write((char *)&blockAlign, 2);
    file.write((char *)&bitsPerSample, 2);

    file.write("data", 4);
    file.write((char *)&dataSize, 4);
}

std::vector<char> RecordPulse(const char *source, int seconds,
                              int sampleRate = 44100,
                              int channels = 2,
                              int bitsPerSample = 16) {
    pa_sample_spec ss;
    ss.format = PA_SAMPLE_S16LE;
    ss.rate = sampleRate;
    ss.channels = channels;

    int error;
    pa_simple *s = pa_simple_new(NULL,                // server (NULL = default)
                                 "RecorderApp",       // app name
                                 PA_STREAM_RECORD,
                                 source,              // source (NULL = default mic, or e.g. "alsa_output.pci-0000_00_1b.0.analog-stereo.monitor")
                                 "record",            // stream description
                                 &ss,                 // sample format
                                 NULL,                // channel map
                                 NULL,                // buffering attributes
                                 &error);

    if (!s) {
        std::cerr << "pa_simple_new() failed: " << pa_strerror(error) << "\n";
        return {};
    }

    int frameSize = channels * (bitsPerSample / 8);
    int bufferFrames = 1024;
    std::vector<char> buffer(bufferFrames * frameSize);
    std::vector<char> audioData;

    int loops = (seconds * sampleRate) / bufferFrames;
    for (int i = 0; i < loops; i++) {
        if (pa_simple_read(s, buffer.data(), buffer.size(), &error) < 0) {
            std::cerr << "pa_simple_read() failed: " << pa_strerror(error) << "\n";
            break;
        }
        audioData.insert(audioData.end(), buffer.begin(), buffer.end());
    }

    pa_simple_free(s);
    return audioData;
}

void SaveToWav(const std::string &filename, const std::vector<char> &data, int sampleRate, int channels, int bitsPerSample) {
    std::ofstream out(filename, std::ios::binary);
    WriteWavHeader(out, sampleRate, channels, bitsPerSample, (int)data.size());
    out.write(data.data(), data.size());
    out.close();
}

int main() {
    int sampleRate = 44100;
    int channels = 2;
    int bits = 16;

    // Record mic (default source)
    auto micData = RecordPulse(NULL, 5, sampleRate, channels, bits);
    SaveToWav("mic_record.wav", micData, sampleRate, channels, bits);
    std::cout << "Saved mic_record.wav\n";

    // Record loopback (monitor source)
    // Để liệt kê tất cả source có thể dùng: `pactl list short sources`
    // VD: "alsa_output.pci-0000_00_1f.3.analog-stereo.monitor"
    auto loopData = RecordPulse("alsa_output.pci-0000_00_1f.3.analog-stereo.monitor", 5, sampleRate, channels, bits);
    SaveToWav("loopback_record.wav", loopData, sampleRate, channels, bits);
    std::cout << "Saved loopback_record.wav\n";

    return 0;
}
