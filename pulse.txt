#include <pulse/pulseaudio.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>

// ====== WAV helper ======
void WriteWavHeader(std::ofstream &file, int sampleRate, int channels,
                    int bitsPerSample, int dataSize) {
    int byteRate = sampleRate * channels * bitsPerSample / 8;
    int blockAlign = channels * bitsPerSample / 8;
    int chunkSize = 36 + dataSize;

    file.write("RIFF", 4);
    file.write((char *)&chunkSize, 4);
    file.write("WAVE", 4);
    file.write("fmt ", 4);

    int subChunk1Size = 16;
    short audioFormat = 1;
    file.write((char *)&subChunk1Size, 4);
    file.write((char *)&audioFormat, 2);
    file.write((char *)&channels, 2);
    file.write((char *)&sampleRate, 4);
    file.write((char *)&byteRate, 4);
    file.write((char *)&blockAlign, 2);
    file.write((char *)&bitsPerSample, 2);

    file.write("data", 4);
    file.write((char *)&dataSize, 4);
}

// ====== Global state ======
static pa_mainloop *mainloop;
static pa_context *context;
static pa_stream *stream;
static std::ofstream wavFile;
static int sampleRate = 44100;
static int channels = 2;
static int bitsPerSample = 16;
static int totalBytes = 0;
static std::string target_app = "Firefox"; // chọn app cần record

// ====== Recording callbacks ======
void stream_read_cb(pa_stream *s, size_t length, void *userdata) {
    const void *data;
    if (pa_stream_peek(s, &data, &length) < 0 || !data) return;

    wavFile.write((const char *)data, length);
    totalBytes += length;

    pa_stream_drop(s);
}

void start_recording() {
    pa_sample_spec ss;
    ss.format = PA_SAMPLE_S16LE;
    ss.rate = sampleRate;
    ss.channels = channels;

    stream = pa_stream_new(context, "AppRecorder", &ss, NULL);

    pa_buffer_attr attr;
    attr.fragsize = (uint32_t)-1;
    attr.maxlength = (uint32_t)-1;
    attr.minreq = (uint32_t)-1;
    attr.prebuf = (uint32_t)-1;
    attr.tlength = (uint32_t)-1;

    pa_stream_set_read_callback(stream, stream_read_cb, NULL);

    // connect tới monitor của MySink
    pa_stream_connect_record(stream, "MySink.monitor", &attr,
                             (pa_stream_flags_t)0);
}

// ====== Sink-input callbacks ======
void sink_input_cb(pa_context *c, const pa_sink_input_info *i, int eol, void *userdata) {
    if (eol || !i) return;

    const char *appName = pa_proplist_gets(i->proplist, "application.name");
    if (appName) {
        std::cout << "SinkInput " << i->index << " app=" << appName << "\n";
    }

    if (appName && std::string(appName).find(target_app) != std::string::npos) {
        std::cout << "==> Found target app: " << appName << " index=" << i->index << "\n";

        // Move sang MySink
        pa_operation *o = pa_context_move_sink_input_by_name(c, i->index, "MySink", NULL, NULL);
        if (o) pa_operation_unref(o);

        // Bắt đầu record MySink.monitor
        wavFile.open("app_record.wav", std::ios::binary);
        WriteWavHeader(wavFile, sampleRate, channels, bitsPerSample, 0);
        start_recording();
    }
}

// ====== Context state callback ======
void context_state_cb(pa_context *c, void *userdata) {
    switch (pa_context_get_state(c)) {
        case PA_CONTEXT_READY:
            std::cout << "Connected to PulseAudio\n";

            // Tạo null sink
            pa_context_load_module(c, "module-null-sink",
                "sink_name=MySink sink_properties=device.description=MySink",
                NULL, NULL);

            // Loopback để bạn vẫn nghe được
            pa_context_load_module(c, "module-loopback",
                "source=MySink.monitor sink=@DEFAULT_SINK@",
                NULL, NULL);

            // Lấy danh sách app (sink-inputs)
            pa_operation *o = pa_context_get_sink_input_info_list(c, sink_input_cb, NULL);
            if (o) pa_operation_unref(o);
            break;

        case PA_CONTEXT_FAILED:
        case PA_CONTEXT_TERMINATED:
            pa_mainloop_quit(mainloop, 0);
            break;
        default: break;
    }
}

int main() {
    mainloop = pa_mainloop_new();
    context = pa_context_new(pa_mainloop_get_api(mainloop), "AppLoopbackRecorder");

    pa_context_set_state_callback(context, context_state_cb, NULL);
    pa_context_connect(context, NULL, 0, NULL);

    int ret;
    pa_mainloop_run(mainloop, &ret);

    // Close WAV properly
    if (wavFile.is_open()) {
        wavFile.seekp(4 + 4, std::ios::beg); // chunk size offset
        int chunkSize = 36 + totalBytes;
        wavFile.write((char *)&chunkSize, 4);
        wavFile.seekp(40, std::ios::beg); // data size offset
        wavFile.write((char *)&totalBytes, 4);
        wavFile.close();
    }

    pa_stream_disconnect(stream);
    pa_stream_unref(stream);
    pa_context_disconnect(context);
    pa_context_unref(context);
    pa_mainloop_free(mainloop);

    std::cout << "Saved app_record.wav\n";
    return 0;
}
